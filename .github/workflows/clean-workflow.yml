name: Cleanup Workflow Runs
on:
  schedule:
    # 每周日北京时间 0 点自动运行 (UTC 周六 16:00)
    - cron: '0 16 * * 6'
  workflow_dispatch:
    inputs:
      keep_days:
        description: "保留最近多少天（0=全部清理，默认0）"
        required: false
        default: "0"
      repositories:
        description: "要清理的仓库（格式：owner/repo，多个用逗号分隔，留空为当前仓库，输入 'all' 清理所有仓库）"
        required: false
        default: "all"

# 防止并发运行
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: 安装依赖
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: 设置目标仓库列表
        id: set-repos
        env:
          GH_TOKEN: ${{ secrets.AUTH_PAT }}
        run: |
          if [ -z "${{ github.event.inputs.repositories }}" ]; then
            REPOS="${{ github.repository }}"
            MODE="current"
          elif [ "${{ github.event.inputs.repositories }}" = "all" ]; then
            REPOS="all"
            MODE="all"
          else
            REPOS="${{ github.event.inputs.repositories }}"
            MODE="manual"
          fi
        
          # 如果模式是all，获取所有仓库（优化：仅获取owner和collaborator权限的仓库）
          if [ "$MODE" = "all" ]; then
            echo "🔍 正在获取您有权限的所有仓库..."
            
            page=1
            ALL_REPOS=""
            
            while true; do
              RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: token $GH_TOKEN" \
                            "https://api.github.com/user/repos?per_page=100&page=$page&affiliation=owner,collaborator&sort=full_name")
              
              HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
              BODY=$(echo "$RESPONSE" | sed '$d')
              
              if [ "$HTTP_CODE" != "200" ]; then
                echo "❌ API 请求失败 (代码 $HTTP_CODE)"
                echo "响应: $BODY"
                # 不退出，继续处理已获取的仓库
                break
              fi
              
              REPOS_PAGE=$(echo "$BODY" | jq -r '.[].full_name' 2>/dev/null | tr '\n' ',')
              
              if [ -z "$REPOS_PAGE" ] || [ "$REPOS_PAGE" = "" ]; then
                break
              fi
              
              ALL_REPOS="${ALL_REPOS}${REPOS_PAGE}"
              page=$((page + 1))
              
              TOTAL_PROCESSED=$(( (page-1) * 100 ))
              echo "📊 已获取 $TOTAL_PROCESSED 个仓库..."
              
              if [ $page -gt 20 ]; then
                echo "⚠️ 注意：已获取 2000 个仓库，如需更多请调整 page 限制"
                break
              fi
              
              sleep 0.5
            done
            
            REPOS=${ALL_REPOS%,}
            REPO_COUNT=$(echo "$REPOS" | tr ',' '\n' | wc -l)
            echo "✅ 共找到 $REPO_COUNT 个仓库"
          fi
        
          # 清理格式
          REPOS=$(echo "$REPOS" | tr -d ' ' | sed 's/,,*/,/g' | sed 's/^,//' | sed 's/,$//')
        
          echo "repositories=$REPOS" >> $GITHUB_OUTPUT
          echo "mode=$MODE" >> $GITHUB_OUTPUT
          
          if [ "$MODE" = "all" ]; then
            echo "🔍 模式：$MODE，将清理所有仓库 (共 $REPO_COUNT 个)"
          else
            echo "🔍 模式：$MODE，将清理仓库：$REPOS"
          fi

      - name: 清理工作流运行 (最终优化版)
        id: cleanup-run
        env:
          KEEP_DAYS: ${{ github.event.inputs.keep_days }}
          REPOSITORIES: ${{ steps.set-repos.outputs.repositories }}
          GH_TOKEN: ${{ secrets.AUTH_PAT }}
        run: |
          : "${KEEP_DAYS:=0}"
        
          echo "=========================================="
          echo "🧹 工作流清理任务启动"
          echo "=========================================="
          echo "参数配置："
          echo " - 保留天数: $KEEP_DAYS (0=全部清理)"
          echo " - 目标仓库数量: $(echo "$REPOSITORIES" | tr ',' '\n' | wc -l) 个"
          echo " - 模式: ${{ steps.set-repos.outputs.mode }}"
          echo "=========================================="
        
          if [ -z "$REPOSITORIES" ]; then
            echo "❌ 错误：未指定要清理的仓库"
            exit 1
          fi
        
          # 计算时间阈值（如果设置了保留天数）
          if [ "$KEEP_DAYS" -gt 0 ]; then
            THRESHOLD=$(date -u -d "${KEEP_DAYS} days ago" '+%Y-%m-%dT%H:%M:%SZ')
            echo "📅 保留策略: 保留最近 $KEEP_DAYS 天的运行记录"
            echo "⏰ 阈值时间(UTC): $THRESHOLD"
            TIME_FILTER="&created=<$THRESHOLD"
          else
            echo "⚠️ 注意: 将清理所有已完成的工作流运行"
            TIME_FILTER=""
          fi
        
          IFS=',' read -ra REPO_ARRAY <<< "$REPOSITORIES"
        
          BATCH_SIZE=10
          TOTAL_REPOS=${#REPO_ARRAY[@]}
          CURRENT_INDEX=0
        
          TOTAL_DELETED_GLOBAL=0
          TOTAL_SKIPPED_GLOBAL=0
          TOTAL_FAILED_GLOBAL=0
          PROCESSED_REPOS=0
        
          for TARGET_REPO in "${REPO_ARRAY[@]}"; do
            CURRENT_INDEX=$((CURRENT_INDEX + 1))
            PROCESSED_REPOS=$((PROCESSED_REPOS + 1))
           
            if (( CURRENT_INDEX % BATCH_SIZE == 0 )) || (( CURRENT_INDEX == TOTAL_REPOS )); then
              echo ""
              echo "📈 进度: $CURRENT_INDEX/$TOTAL_REPOS 个仓库"
            fi
           
            echo ""
            echo "========================================"
            echo "🎯 开始清理仓库 ($CURRENT_INDEX/$TOTAL_REPOS): $TARGET_REPO"
            echo "========================================"
          
            TOTAL_DELETED=0
            TOTAL_FAILED=0
            page=1
            REPO_SKIPPED=0
            
            echo "🔍 直接获取工作流运行记录 (EAFP策略)..."
          
            while true; do
              echo "📄 正在获取第 $page 页..."
            
              # 核心优化：使用EAFP策略，直接获取运行记录，不进行前置检查
              RESPONSE=$(curl -s -w "\n%{http_code}" -H "Authorization: token $GH_TOKEN" \
                            "https://api.github.com/repos/$TARGET_REPO/actions/runs?per_page=100&page=$page&status=completed${TIME_FILTER}")
            
              HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
              BODY=$(echo "$RESPONSE" | sed '$d')
            
              # 错误处理：如果API返回错误，跳过该仓库
              if [ "$HTTP_CODE" != "200" ]; then
                ERROR_MSG=$(echo "$BODY" | jq -r '.message // "未知错误"' 2>/dev/null || echo "未知错误")
                if [ "$page" -eq 1 ]; then
                  if [ "$HTTP_CODE" = "404" ]; then
                    echo "❌ 仓库 '$TARGET_REPO' 不存在或无权访问"
                  elif [ "$HTTP_CODE" = "403" ]; then
                    echo "❌ 权限不足，无法访问仓库 '$TARGET_REPO'"
                  else
                    echo "❌ API 错误 ($HTTP_CODE): $ERROR_MSG"
                  fi
                  TOTAL_SKIPPED_GLOBAL=$((TOTAL_SKIPPED_GLOBAL + 1))
                  REPO_SKIPPED=1
                fi
                break
              fi
            
              # 检查是否有工作流运行记录
              if ! echo "$BODY" | jq -e '.workflow_runs' > /dev/null 2>&1; then
                if [ $page -eq 1 ]; then
                  echo "✅ 仓库没有工作流运行记录，无需清理"
                fi
                break
              fi
            
              # 提取要删除的运行ID
              RUN_IDS=$(echo "$BODY" | jq -r '.workflow_runs[].id' 2>/dev/null | tr '\n' ' ')
            
              if [ -z "$RUN_IDS" ] || [ "$RUN_IDS" = " " ]; then
                echo "✅ 第 $page 页没有可删除的运行"
                
                # 检查是否还有更多页
                TOTAL_COUNT=$(echo "$BODY" | jq -r '.total_count // 0' 2>/dev/null)
                TOTAL_PROCESSED=$(( (page-1) * 100 ))
                if [ $TOTAL_PROCESSED -ge $TOTAL_COUNT ]; then
                  echo "📊 已处理完所有 $TOTAL_COUNT 个记录"
                  break
                fi
              else
                RUN_IDS=$(echo "$RUN_IDS" | xargs)
                COUNT=$(echo "$RUN_IDS" | wc -w)
                echo "🗑️ 第 $page 页发现 $COUNT 个待删除运行"
              
                for RUN_ID in $RUN_IDS; do
                  echo -n "."
                
                  DELETE_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
                    -H "Authorization: token $GH_TOKEN" \
                    "https://api.github.com/repos/$TARGET_REPO/actions/runs/$RUN_ID")
                
                  if [ "$DELETE_RESPONSE" = "204" ]; then
                    TOTAL_DELETED=$((TOTAL_DELETED + 1))
                    TOTAL_DELETED_GLOBAL=$((TOTAL_DELETED_GLOBAL + 1))
                  else
                    TOTAL_FAILED=$((TOTAL_FAILED + 1))
                    TOTAL_FAILED_GLOBAL=$((TOTAL_FAILED_GLOBAL + 1))
                  fi
                
                  # 小延迟避免API限制
                  sleep 0.1
                done
              
                echo "" # 换行
                echo "📊 第 $page 页完成: 删除 $TOTAL_DELETED 个，失败 $TOTAL_FAILED 个"
              fi
            
              # 检查是否还有更多数据
              ITEM_COUNT=$(echo "$BODY" | jq -r '.workflow_runs | length' 2>/dev/null)
              if [ "$ITEM_COUNT" -lt 100 ]; then
                break
              fi
            
              page=$((page + 1))
              sleep 0.3
            done
          
            echo ""
            if [ "$REPO_SKIPPED" -eq 1 ]; then
              echo "⏭️ 仓库 $TARGET_REPO 已跳过"
            else
              echo "✅ 仓库 $TARGET_REPO 清理完成"
              echo "📈 统计：成功删除 $TOTAL_DELETED 个运行，失败 $TOTAL_FAILED 个"
            fi
            echo ""
          done
        
          echo "=========================================="
          echo "🎉 所有指定仓库清理完成！"
          echo "=========================================="
          echo ""
          echo "📋 最终统计："
          echo "  总共处理仓库数: $PROCESSED_REPOS"
          echo "  成功清理仓库数: $((PROCESSED_REPOS - TOTAL_SKIPPED_GLOBAL))"
          echo "  跳过仓库数: $TOTAL_SKIPPED_GLOBAL"
          echo "  删除运行记录总数: $TOTAL_DELETED_GLOBAL"
          echo "  删除失败次数: $TOTAL_FAILED_GLOBAL"
          echo "  模式: ${{ steps.set-repos.outputs.mode }}"
          echo ""
        
          # 设置输出变量
          echo "processed_repos=$PROCESSED_REPOS" >> $GITHUB_OUTPUT
          echo "deleted_runs=$TOTAL_DELETED_GLOBAL" >> $GITHUB_OUTPUT
          echo "skipped_repos=$TOTAL_SKIPPED_GLOBAL" >> $GITHUB_OUTPUT
          echo "failed_deletes=$TOTAL_FAILED_GLOBAL" >> $GITHUB_OUTPUT

      - name: 生成报告
        if: always()
        env:
          MODE: ${{ steps.set-repos.outputs.mode }}
          PROCESSED_REPOS: ${{ steps.cleanup-run.outputs.processed_repos || 0 }}
          DELETED_RUNS: ${{ steps.cleanup-run.outputs.deleted_runs || 0 }}
          SKIPPED_REPOS: ${{ steps.cleanup-run.outputs.skipped_repos || 0 }}
          FAILED_DELETES: ${{ steps.cleanup-run.outputs.failed_deletes || 0 }}
          KEEP_DAYS: ${{ github.event.inputs.keep_days || 0 }}
        run: |
          echo "## 🧹 工作流清理报告" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**执行时间:** $(date '+%Y-%m-%d %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
          echo "**触发方式:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**清理模式:** $MODE" >> $GITHUB_STEP_SUMMARY
          echo "**保留天数:** $KEEP_DAYS 天" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "**状态:** ✅ 清理任务执行完成" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### 📊 清理统计" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| 项目 | 数量 | 说明 |" >> $GITHUB_STEP_SUMMARY
            echo "|------|------|------|" >> $GITHUB_STEP_SUMMARY
            echo "| 📦 目标仓库数 | $PROCESSED_REPOS | 计划处理的仓库总数 |" >> $GITHUB_STEP_SUMMARY
            echo "| ✅ 成功清理 | $((PROCESSED_REPOS - SKIPPED_REPOS)) | 成功完成清理的仓库 |" >> $GITHUB_STEP_SUMMARY
            echo "| 🗑️ 删除运行记录 | $DELETED_RUNS | 删除的 workflow runs 总数 |" >> $GITHUB_STEP_SUMMARY
            echo "| ⏭️ 跳过仓库 | $SKIPPED_REPOS | 无权限或无workflow的仓库 |" >> $GITHUB_STEP_SUMMARY
            echo "| ❌ 删除失败 | $FAILED_DELETES | 删除操作失败的次数 |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "### 🚀 优化特性" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "1. **EAFP策略**：直接尝试清理，而不是先检查权限，减少50% API调用" >> $GITHUB_STEP_SUMMARY
            echo "2. **服务器端过滤**：使用 `created=<$THRESHOLD` 让GitHub服务器过滤，减少数据传输" >> $GITHUB_STEP_SUMMARY
            echo "3. **精准权限**：仅扫描owner和collaborator权限的仓库，排除无权限的org仓库" >> $GITHUB_STEP_SUMMARY
            echo "4. **并发安全**：防止同时运行多个清理任务" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            echo "### 🔄 下次自动运行时间" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- **北京时间每周日 00:00** (UTC 周六 16:00)" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            if [ "$KEEP_DAYS" = "0" ]; then
              echo "> ⚠️ 注意：本次清理了所有已完成的工作流运行，如需保留历史记录，请设置 `keep_days` 参数" >> $GITHUB_STEP_SUMMARY
            else
              echo "> ℹ️ 本次保留了最近 $KEEP_DAYS 天的工作流运行记录" >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "**状态:** ❌ 清理任务执行失败" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "请查看详细日志了解错误信息。" >> $GITHUB_STEP_SUMMARY
          fi

# ========================================
# 配置说明：
# 1. 创建 Personal Access Token (PAT)：
#    - 访问 GitHub → Settings → Developer settings → Personal access tokens
#    - 生成 token，至少选择权限：repo (完全访问仓库)、workflow (读写工作流)
#    
# 2. 将 PAT 添加到仓库 Secrets：
#    - 进入仓库 → Settings → Secrets and variables → Actions
#    - 新建 Secret，名称：AUTH_PAT，值：粘贴刚才复制的 token
#    - 在所有需要运行清理的仓库（如 temp, rule 等）都添加相同的 AUTH_PAT
#    - 仓库的 Workflow permissions 只影响 GITHUB_TOKEN，不影响 AUTH_PAT
#    
# 3. 使用说明：
#    - 定时任务：每周日0点自动运行，默认清理所有已完成运行
#    - 手动触发：可指定保留天数(0=全部清理)和仓库列表(逗号分隔)
#    - 示例：repositories: user/repo1,user/repo2，keep_days: 7
#    - all = 自动获取并清理所有有权限的仓库（推荐用于批量管理）
#
# 4. 使用 AUTH_PAT - 可以直接复制到任何仓库
#    secrets.AUTH_PAT
#    使用 GITHUB_TOKEN - 仅限当前仓库，无跨项目权限，是 GitHub Actions 运行时自动生成的临时 token
#    secrets.GITHUB_TOKEN
# ========================================
